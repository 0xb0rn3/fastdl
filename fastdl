#!/usr/bin/env bash

# VM Lab Isolation Setup Script
# Author: 0xbv1 | 0xb0rn3
# Repository: github.com/0xb0rn3/Qemu-pentest
# Description: Automated setup for isolated VM environments for penetration testing

set -euo pipefail

# Configuration
SCRIPT_VERSION="1.4.0" # Updated version with enhanced networking
LOG_FILE="/tmp/vm-isolation-setup.log"
BACKUP_DIR="/tmp/vm-backups"
DEFAULT_VLAN=100
DEFAULT_BRIDGE="br0"

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Supported USB WiFi adapters database
declare -A ADAPTERS=(
    ["0e8d:7612"]="MediaTek MT7612U:yes:yes:recommended"
    ["0bda:8812"]="Realtek RTL8812AU:yes:yes:good"
    ["0bda:b812"]="Realtek RTL88x2bu:yes:limited:ok"
    ["148f:7601"]="Ralink MT7601U:yes:no:basic"
    ["0cf3:9271"]="Atheros AR9271:yes:yes:good"
    ["2357:0105"]="TP-Link AC600:yes:yes:good"
)

# Global variables
VM_NAME=""
USB_VENDOR=""
USB_PRODUCT=""
HOST_INTERFACE=""
VLAN_ID="$DEFAULT_VLAN"
BRIDGE_NAME="$DEFAULT_BRIDGE"
PERSISTENT=false
DRY_RUN=false
VERBOSE=false
CREATE_NEW_VM=false
ISO_PATH=""
VM_MEMORY=""
VM_CORES=""
VM_DISK_SIZE=""
VM_OS_VARIANT="linux2022"  # Default OS variant
NETWORK_TOPOLOGY=""
SECURITY_LEVEL=""
BRIDGE_NAME_SECONDARY=""

# Logging function
log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >> "$LOG_FILE"
    if [[ "$VERBOSE" == true ]]; then
        echo -e "${BLUE}[LOG]${NC} $1"
    fi
}

# Print functions
print_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
    log "INFO: $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
    log "SUCCESS: $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
    log "WARNING: $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
    log "ERROR: $1"
}

# Help function
show_help() {
    cat << EOF
VM Lab Isolation Setup Script v$SCRIPT_VERSION
Author: 0xbv1 | 0xb0rn3 (github.com/0xb0rn3/Qemu-pentest)

USAGE:
    $0 [OPTIONS]

OPTIONS:
    --vm NAME               Specify VM name directly
    --create-vm             Create new VM from ISO
    --iso PATH              Path to ISO file for new VM creation
    --download-iso          Prompt to download an ISO automatically
    --adapter VENDOR:PRODUCT Specify USB adapter (e.g., 0e8d:7612)
    --vlan ID               Custom VLAN ID (default: 100)
    --interface NAME        Host interface to bridge
    --bridge NAME           Bridge name (default: br0)
    --memory SIZE           VM memory in MB (for new VMs)
    --cores NUM             VM CPU cores (for new VMs)
    --disk SIZE             VM disk size in GB (for new VMs)
    --persistent            Make bridge persistent across reboots
    --dry-run               Show what would be done without applying
    --restore FILE          Restore VM from backup XML
    --list-adapters         Show supported USB adapters
    --list-vms              Show available VMs
    --verbose               Enable verbose output
    --help                  Show this help message

EXAMPLES:
    # Interactive setup
    sudo $0

    # Create new VM with isolation
    sudo $0 --create-vm --iso /path/to/kali.iso --vm kali-lab

    # Configure existing VM
    sudo $0 --vm existing-vm --adapter 0e8d:7612

    # Custom network setup
    sudo $0 --vm test-vm --vlan 200 --interface eth1

EOF
}

# Check dependencies
check_dependencies() {
    local deps=("virsh" "ip" "lsusb" "xmllint" "systemctl" "virt-install" "free" "nproc" "bridge" "awk")
    local missing=()

    for dep in "${deps[@]}"; do
        if ! command -v "$dep" &> /dev/null; then
            missing+=("$dep")
        fi
    done

    if [[ ${#missing[@]} -ne 0 ]]; then
        print_error "Missing dependencies: ${missing[*]}"
        print_info "Please install required packages:"
        print_info "Ubuntu/Debian: sudo apt install libvirt-clients iproute2 usbutils libxml2-utils systemd virtinst procps bridge-utils gawk"
        print_info "Arch Linux: sudo pacman -S libvirt iproute2 usbutils libxml2 systemd virt-install coreutils bridge-utils gawk"
        exit 1
    fi
}

# Check root privileges
check_root() {
    if [[ $EUID -ne 0 ]]; then
        print_error "This script must be run as root (use sudo)"
        exit 1
    fi
}

# Check if libvirt is running
check_libvirt() {
    if ! systemctl is-active --quiet libvirtd; then
        print_warning "libvirtd is not running, attempting to start..."
        systemctl start libvirtd || {
            print_error "Failed to start libvirtd"
            exit 1
        }
    fi
}

# Prints system resource info
print_system_resources() {
    local total_memory=$(free -m | awk '/^Mem:/{print $2}')
    local total_cores=$(nproc)

    print_info "System Resources:"
    print_info "  Total Memory: ${total_memory}MB"
    print_info "  Total Cores: $total_cores"
}

# Returns recommended system resources
get_system_resource_recommendations() {
    local total_memory=$(free -m | awk '/^Mem:/{print $2}')
    local total_cores=$(nproc)

    # Calculate recommended resources with proper integer arithmetic
    local rec_memory=$((total_memory / 4))  # 25% of total memory
    local min_memory=1024  # 1GB minimum
    local max_memory=$((total_memory * 3 / 4))  # 75% of total memory max

    local rec_cores=2  # Recommended 2 cores
    local min_cores=1
    local max_cores=$((total_cores > 1 ? total_cores - 1 : 1))  # Leave 1 core for host

    # Ensure minimums are respected
    if [[ $rec_memory -lt $min_memory ]]; then
        rec_memory=$min_memory
    fi

    # Return values as colon-separated string for parsing
    echo "${rec_memory}:${min_memory}:${max_memory}:${rec_cores}:${min_cores}:${max_cores}"
}

# OS variants database - maps friendly names to osinfo values
declare -A OS_VARIANTS=(
    ["Debian 11 (Bullseye)"]="debian11"
    ["Debian 12 (Bookworm)"]="debian12"
    ["Ubuntu 20.04 LTS"]="ubuntu20.04"
    ["Ubuntu 22.04 LTS"]="ubuntu22.04"
    ["Ubuntu 24.04 LTS"]="ubuntu24.04"
    ["Kali Linux"]="debian11"  # Kali is based on Debian
    ["Parrot OS"]="debian11"   # Parrot is based on Debian
    ["Arch Linux"]="archlinux"
    ["BlackArch"]="archlinux"  # BlackArch is based on Arch
    ["Garuda Linux"]="archlinux" # Garuda is based on Arch
)

# Network topology types
declare -A NETWORK_TOPOLOGIES=(
    ["isolated"]="Isolated VLAN with NAT:Complete isolation with internet access"
    ["bridged"]="Direct bridge access:VM on same network as host"
    ["host-only"]="Host-only network:VM can only communicate with host"
    ["dual-nic"]="Dual NIC setup:One isolated, one bridged interface"
    ["custom"]="Custom configuration:Manual network setup"
)

# Network security levels
declare -A SECURITY_LEVELS=(
    ["high"]="Maximum isolation:No direct host access, strict firewall rules"
    ["medium"]="Balanced security:Limited host access, monitored traffic"
    ["low"]="Basic isolation:Standard NAT with minimal restrictions"
    ["pentest"]="Penetration testing:Optimized for security testing tools"
)

# Interactive OS selection
select_os_variant() {
    # Print menu directly to the terminal, not stdout
    echo "Select OS type for optimal VM configuration:" > /dev/tty
    local os_names=()
    local i=1

    # Build array of OS names for selection
    for os_name in "${!OS_VARIANTS[@]}"; do
        echo "$i) $os_name" > /dev/tty
        os_names+=("$os_name")
        ((i++))
    done

    echo "$i) Other/Generic Linux" > /dev/tty

    while true; do
        # Read from the terminal
        read -p "Select OS (1-$i): " -r selection < /dev/tty
        if [[ "$selection" =~ ^[0-9]+$ ]] && [[ "$selection" -ge 1 ]] && [[ "$selection" -le $i ]]; then
            if [[ "$selection" -eq $i ]]; then
                echo "linux2022"  # This goes to stdout
                return
            else
                local selected_os="${os_names[$((selection-1))]}"
                echo "${OS_VARIANTS[$selected_os]}" # This goes to stdout
                return
            fi
        else
            # Print error to the terminal
            print_error "Invalid selection. Please enter a number between 1 and $i." > /dev/tty
        fi
    done
}

# FastDL integration for ISO downloads
declare -A ISO_URLS=(
    ["Kali Linux"]="https://cdimage.kali.org/kali-2025.2/kali-linux-2025.2-installer-amd64.iso"
    ["Parrot OS"]="https://deb.parrot.sh/parrot/iso/6.2/Parrot-security-6.2_amd64.iso"
    ["Ubuntu 22.04"]="https://releases.ubuntu.com/22.04/ubuntu-22.04.4-desktop-amd64.iso"
    ["Ubuntu 24.04"]="https://releases.ubuntu.com/24.04/ubuntu-24.04.1-desktop-amd64.iso"
    ["Debian 12"]="https://cdimage.debian.org/debian-cd/current/amd64/iso-cd/debian-12.8.0-amd64-netinst.iso"
    ["Arch Linux"]="https://archlinux.org/iso/latest/archlinux-x86_64.iso"
    ["BlackArch"]="https://blackarch.org/downloads.html#iso"
    ["Garuda Linux"]="https://iso.builds.garudalinux.org/iso/latest/garuda/dr460nized/latest.iso"
)

# Download ISO using FastDL
download_iso() {
    local os_choice="$1"
    local download_dir="/tmp/vm-isos"
    local iso_filename

    # Create download directory
    mkdir -p "$download_dir"

    # Get ISO URL
    local iso_url="${ISO_URLS[$os_choice]}"
    if [[ -z "$iso_url" ]]; then
        print_error "No download URL available for $os_choice"
        return 1
    fi

    # Extract filename from URL
    iso_filename=$(basename "$iso_url")
    local full_path="$download_dir/$iso_filename"

    # Check if already downloaded
    if [[ -f "$full_path" ]]; then
        print_info "ISO already exists: $full_path"
        echo "$full_path"
        return 0
    fi

    print_info "Downloading $os_choice ISO..."
    print_info "This may take several minutes depending on your connection..."

    # Setup FastDL if not present
    setup_fastdl

    # Download using FastDL
    if ./fastdl "$iso_url" "$full_path"; then
        print_success "Download completed: $full_path"
        echo "$full_path"
        return 0
    else
        print_error "Download failed for $os_choice"
        return 1
    fi
}

# Setup FastDL binary
setup_fastdl() {
    local fastdl_url="https://github.com/0xb0rn3/fastdl/releases/latest/download/fastdl-linux-amd64"

    if [[ ! -f "./fastdl" ]]; then
        print_info "Setting up FastDL downloader..."

        if command -v wget &> /dev/null; then
            wget -q "$fastdl_url" -O ./fastdl
        elif command -v curl &> /dev/null; then
            curl -sL "$fastdl_url" -o ./fastdl
        else
            print_error "Neither wget nor curl available for downloading FastDL"
            return 1
        fi

        chmod +x ./fastdl
        print_success "FastDL ready"
    fi
}

# Cleanup FastDL after use
cleanup_fastdl() {
    if [[ -f "./fastdl" ]]; then
        rm -f ./fastdl
        print_info "Cleaned up FastDL binary"
    fi
}

# Detect existing VMs
detect_vms() {
    print_info "Detecting existing VMs..." >&2 # FIX: Redirect info to stderr
    local vms=$(virsh list --all --name | grep -v '^$')

    if [[ -z "$vms" ]]; then
        print_warning "No existing VMs found" >&2 # FIX: Redirect warning to stderr
        return 1
    fi

    echo "$vms"
    return 0
}

# Fixed USB WiFi adapter detection
detect_usb_adapters() {
    # FIX: Redirect info messages to stderr to avoid polluting function output
    print_info "Scanning for USB WiFi adapters..." >&2
    local found_adapters=()

    # Use a more reliable way to parse lsusb output
    while IFS= read -r line; do
        if [[ "$line" =~ ID[[:space:]]+([0-9a-f]{4}):([0-9a-f]{4}) ]]; then
            local vendor_id="${BASH_REMATCH[1]}"
            local product_id="${BASH_REMATCH[2]}"
            local vendor_product="${vendor_id}:${product_id}"

            if [[ -n "${ADAPTERS[$vendor_product]:-}" ]]; then
                local adapter_info="${ADAPTERS[$vendor_product]}"
                # Securely pass info, separating fields with a unique, safe delimiter
                found_adapters+=("${vendor_product}|${adapter_info}")
            fi
        fi
    done < <(lsusb)

    if [[ ${#found_adapters[@]} -eq 0 ]]; then
        print_warning "No supported USB WiFi adapters found." >&2
        return 1
    fi

    # Print each adapter on a new line for the calling function to process
    printf '%s\n' "${found_adapters[@]}"
    return 0
}

# Generate MAC address
generate_mac() {
    printf '52:54:00:%02x:%02x:%02x\n' $((RANDOM%256)) $((RANDOM%256)) $((RANDOM%256))
}

# Find next available PCI slot
find_next_pci_slot() {
    local vm_name="$1"
    local xml_content=$(virsh dumpxml "$vm_name")
    local used_slots=()

    # Extract used PCI slots
    while IFS= read -r line; do
        if [[ "$line" =~ slot=\'0x([0-9a-f]+)\' ]]; then
            used_slots+=("$((16#${BASH_REMATCH[1]}))")
        fi
    done <<< "$xml_content"

    # Find next available slot (starting from 0x03, 0x02 is usually reserved)
    for ((slot=3; slot<=31; slot++)); do
        if [[ ! " ${used_slots[*]} " =~ " $slot " ]]; then
            printf '0x%02x' "$slot"
            return
        fi
    done

    print_error "No available PCI slots found"
    exit 1
}

# Find next available USB port
find_next_usb_port() {
    local vm_name="$1"
    local xml_content=$(virsh dumpxml "$vm_name")
    local used_ports=()

    # Extract used USB ports
    while IFS= read -r line; do
        if [[ "$line" =~ port=\'([0-9]+)\' ]]; then
            used_ports+=("${BASH_REMATCH[1]}")
        fi
    done <<< "$xml_content"

    # Find next available port
    for ((port=1; port<=8; port++)); do
        if [[ ! " ${used_ports[*]} " =~ " $port " ]]; then
            echo "$port"
            return
        fi
    done

    print_error "No available USB ports found"
    exit 1
}

# --- ENHANCED NETWORK SETUP SECTION ---

# Enhanced network interface detection with more details
detect_network_interfaces_enhanced() {
    print_info "Scanning network interfaces..." >&2
    local interfaces_info=()

    while IFS= read -r iface; do
        # Skip loopback, docker, bridge, and virtual interfaces
        if [[ ! "$iface" =~ ^(lo|docker|br|virbr|veth|tun|tap) ]]; then
            local ip_info=$(ip addr show "$iface" 2>/dev/null | awk '/inet / {print $2}' | head -1)
            local link_state=$(ip link show "$iface" 2>/dev/null | awk '/state/ {print $9}')
            local speed=""
            
            # Try to get interface speed (for ethernet interfaces)
            if [[ -f "/sys/class/net/$iface/speed" ]]; then
                speed=$(cat "/sys/class/net/$iface/speed" 2>/dev/null)
                [[ "$speed" != "-1" ]] && speed="${speed}Mbps" || speed="Unknown"
            else
                speed="Wireless/Virtual"
            fi

            local iface_type="Unknown"
            # Determine interface type
            if [[ -d "/sys/class/net/$iface/wireless" ]]; then
                iface_type="WiFi"
            elif [[ -f "/sys/class/net/$iface/device/driver" ]]; then
                iface_type="Ethernet"
            fi

            # Format: interface|ip|state|speed|type
            interfaces_info+=("${iface}|${ip_info:-No IP}|${link_state:-DOWN}|${speed}|${iface_type}")
        fi
    done < <(ip link show | awk -F': ' '/^[0-9]+:/ {print $2}' | cut -d'@' -f1)

    printf '%s\n' "${interfaces_info[@]}"
}

# Enhanced network topology selection
select_network_topology() {
    echo "Available Network Topologies:" > /dev/tty
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━" > /dev/tty
    
    local topologies=()
    local i=1
    
    for topology in "${!NETWORK_TOPOLOGIES[@]}"; do
        local description="${NETWORK_TOPOLOGIES[$topology]}"
        local name=$(echo "$description" | cut -d':' -f1)
        local desc=$(echo "$description" | cut -d':' -f2)
        
        echo "$i) $name" > /dev/tty
        echo "   $desc" > /dev/tty
        echo > /dev/tty
        topologies+=("$topology")
        ((i++))
    done

    while true; do
        read -p "Select network topology (1-$((i-1))): " -r selection < /dev/tty
        if [[ "$selection" =~ ^[0-9]+$ ]] && [[ "$selection" -ge 1 ]] && [[ "$selection" -lt $i ]]; then
            echo "${topologies[$((selection-1))]}"
            return 0
        else
            print_error "Invalid selection. Please enter a number between 1 and $((i-1))." > /dev/tty
        fi
    done
}

# Enhanced security level selection
select_security_level() {
    echo "Security Level Configuration:" > /dev/tty
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━" > /dev/tty
    
    local levels=()
    local i=1
    
    for level in "${!SECURITY_LEVELS[@]}"; do
        local description="${SECURITY_LEVELS[$level]}"
        local name=$(echo "$description" | cut -d':' -f1)
        local desc=$(echo "$description" | cut -d':' -f2)
        
        echo "$i) $level - $name" > /dev/tty
        echo "   $desc" > /dev/tty
        echo > /dev/tty
        levels+=("$level")
        ((i++))
    done

    while true; do
        read -p "Select security level (1-$((i-1))): " -r selection < /dev/tty
        if [[ "$selection" =~ ^[0-9]+$ ]] && [[ "$selection" -ge 1 ]] && [[ "$selection" -lt $i ]]; then
            echo "${levels[$((selection-1))]}"
            return 0
        else
            print_error "Invalid selection. Please enter a number between 1 and $((i-1))." > /dev/tty
        fi
    done
}

# Enhanced interface selection with detailed information
select_network_interface_enhanced() {
    local interfaces_info
    interfaces_info=$(detect_network_interfaces_enhanced)

    if [[ -z "$interfaces_info" ]]; then
        print_error "No suitable network interfaces found"
        exit 1
    fi

    echo "Available Network Interfaces:" > /dev/tty
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━" > /dev/tty
    printf "%-12s %-18s %-8s %-12s %-10s\n" "Interface" "IP Address" "State" "Speed" "Type" > /dev/tty
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━" > /dev/tty
    
    local interface_array=()
    local i=1
    
    while IFS='|' read -r iface ip state speed type; do
        printf "%d) %-8s %-18s %-8s %-12s %-10s\n" "$i" "$iface" "$ip" "$state" "$speed" "$type" > /dev/tty
        interface_array+=("$iface")
        ((i++))
    done <<< "$interfaces_info"
    
    echo > /dev/tty
    local last_index=$((i-1))

    while true; do
        read -p "Select interface (1-$last_index): " -r selection < /dev/tty
        if [[ "$selection" =~ ^[0-9]+$ ]] && [[ "$selection" -ge 1 ]] && [[ "$selection" -le $last_index ]]; then
            echo "${interface_array[$((selection-1))]}"
            return 0
        else
            print_error "Invalid selection. Please enter a number between 1 and $last_index." > /dev/tty
        fi
    done
}

# Enhanced bridge creation with topology support
create_bridge_enhanced() {
    local interface="$1"
    local bridge="$2"
    local vlan="$3"
    local topology="$4"
    local security_level="$5"

    print_info "Setting up $topology network topology with $security_level security..."

    if [[ "$DRY_RUN" == true ]]; then
        print_info "[DRY RUN] Would create $topology bridge configuration"
        return
    fi

    # Check if bridge already exists
    if ip link show "$bridge" &> /dev/null; then
        print_warning "Bridge '$bridge' already exists."
        read -p "Do you want to (d)elete and recreate it, (u)se existing, or (c)ancel? [d/u/c]: " -r choice < /dev/tty
        case "$choice" in
            d|D)
                print_info "Deleting existing bridge..."
                cleanup_existing_bridge "$bridge"
                ;;
            u|U)
                print_info "Using existing bridge '$bridge'."
                return 0
                ;;
            c|C|*)
                print_error "Bridge setup cancelled."
                exit 1
                ;;
        esac
    fi

    # Create bridge based on topology
    case "$topology" in
        "isolated")
            create_isolated_bridge "$interface" "$bridge" "$vlan" "$security_level"
            ;;
        "bridged")
            create_bridged_network "$interface" "$bridge"
            ;;
        "host-only")
            create_hostonly_network "$bridge" "$vlan"
            ;;
        "dual-nic")
            create_dual_nic_setup "$interface" "$bridge" "$vlan" "$security_level"
            ;;
        "custom")
            create_custom_network "$interface" "$bridge" "$vlan"
            ;;
        *)
            print_error "Unknown topology: $topology"
            exit 1
            ;;
    esac

    # Apply security level configurations
    apply_security_rules "$bridge" "$vlan" "$security_level" "$topology"
}

# Isolated bridge with VLAN (original functionality enhanced)
create_isolated_bridge() {
    local interface="$1"
    local bridge="$2"
    local vlan="$3"
    local security_level="$4"

    print_info "Creating isolated bridge with VLAN $vlan..."
    
    # Create bridge
    ip link add name "$bridge" type bridge
    ip link set dev "$bridge" up
    
    # Add interface to bridge
    ip link set dev "$interface" master "$bridge"
    
    # Create VLAN interface
    local vlan_interface="${bridge}.${vlan}"
    ip link add link "$bridge" name "$vlan_interface" type vlan id "$vlan"
    ip link set dev "$vlan_interface" up
    
    # Assign IP based on security level
    case "$security_level" in
        "high"|"pentest")
            ip addr add "10.${vlan}.1.1/24" dev "$vlan_interface"
            ;;
        *)
            ip addr add "192.168.${vlan}.1/24" dev "$vlan_interface"
            ;;
    esac
    
    print_success "Created isolated bridge network"
}

# Direct bridged network (VM on same network as host)
create_bridged_network() {
    local interface="$1"
    local bridge="$2"

    print_info "Creating bridged network..."
    
    # Create bridge
    ip link add name "$bridge" type bridge
    ip link set dev "$bridge" up
    
    # Add interface to bridge
    ip link set dev "$interface" master "$bridge"
    
    # Enable promiscuous mode for better compatibility
    ip link set dev "$bridge" promisc on
    
    print_success "Created bridged network"
}

# Host-only network (VM can only talk to host)
create_hostonly_network() {
    local bridge="$1"
    local vlan="$2"

    print_info "Creating host-only network..."
    
    # Create bridge without adding physical interface
    ip link add name "$bridge" type bridge
    ip link set dev "$bridge" up
    
    # Create virtual interface for host communication
    local host_interface="${bridge}-host"
    ip link add name "$host_interface" type veth peer name "${host_interface}-peer"
    ip link set dev "$host_interface" master "$bridge"
    ip link set dev "$host_interface" up
    ip link set dev "${host_interface}-peer" up
    
    # Assign IP to host side
    ip addr add "172.16.${vlan}.1/24" dev "${host_interface}-peer"
    
    print_success "Created host-only network"
}

# Dual NIC setup (one isolated, one bridged)
create_dual_nic_setup() {
    local interface="$1"
    local bridge="$2" 
    local vlan="$3"
    local security_level="$4"

    print_info "Creating dual NIC setup..."
    
    # Create isolated bridge
    local isolated_bridge="${bridge}-isolated"
    create_isolated_bridge "$interface" "$isolated_bridge" "$vlan" "$security_level"
    
    # Create bridged network
    local bridged_bridge="${bridge}-bridged"
    create_bridged_network "$interface" "$bridged_bridge"
    
    # Store both bridge names for later use
    BRIDGE_NAME="$isolated_bridge"
    BRIDGE_NAME_SECONDARY="$bridged_bridge"
    
    print_success "Created dual NIC setup"
}

# Custom network configuration
create_custom_network() {
    local interface="$1"
    local bridge="$2"
    local vlan="$3"

    print_info "Setting up custom network configuration..."
    
    echo "Custom Network Configuration:" > /dev/tty
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━" > /dev/tty
    
    read -p "Bridge IP address (e.g., 192.168.100.1/24): " -r custom_ip < /dev/tty
    read -p "Enable NAT? [y/n]: " -r enable_nat < /dev/tty
    read -p "Custom iptables rules file (optional, press Enter to skip): " -r custom_rules < /dev/tty
    
    # Create basic bridge
    ip link add name "$bridge" type bridge
    ip link set dev "$bridge" up
    ip link set dev "$interface" master "$bridge"
    
    # Apply custom IP
    [[ -n "$custom_ip" ]] && ip addr add "$custom_ip" dev "$bridge"
    
    # Enable NAT if requested
    if [[ "$enable_nat" =~ ^[Yy]$ ]]; then
        enable_nat_forwarding "$bridge" "$interface"
    fi
    
    # Apply custom rules if provided
    if [[ -n "$custom_rules" && -f "$custom_rules" ]]; then
        print_info "Applying custom iptables rules from $custom_rules"
        bash "$custom_rules"
    fi
    
    print_success "Created custom network"
}

# Enhanced security rule application
apply_security_rules() {
    local bridge="$1"
    local vlan="$2"
    local security_level="$3"
    local topology="$4"

    print_info "Applying $security_level security rules..."

    # Enable IP forwarding
    echo 1 > /proc/sys/net/ipv4/ip_forward

    case "$security_level" in
        "high")
            apply_high_security_rules "$bridge" "$vlan" "$topology"
            ;;
        "medium")
            apply_medium_security_rules "$bridge" "$vlan" "$topology"
            ;;
        "low")
            apply_low_security_rules "$bridge" "$vlan" "$topology"
            ;;
        "pentest")
            apply_pentest_security_rules "$bridge" "$vlan" "$topology"
            ;;
    esac
}

# High security rules (maximum isolation)
apply_high_security_rules() {
    local bridge="$1"
    local vlan="$2"
    local topology="$3"
    
    local vlan_interface="${bridge}.${vlan}"
    local subnet="10.${vlan}.1.0/24"
    
    # Create custom chain for VM traffic
    iptables -t nat -N VM_ISOLATION_OUT 2>/dev/null || true
    iptables -t filter -N VM_ISOLATION_FORWARD 2>/dev/null || true
    
    # NAT rules - only allow outbound internet
    iptables -t nat -A VM_ISOLATION_OUT -s "$subnet" -d 10.0.0.0/8 -j DROP
    iptables -t nat -A VM_ISOLATION_OUT -s "$subnet" -d 172.16.0.0/12 -j DROP
    iptables -t nat -A VM_ISOLATION_OUT -s "$subnet" -d 192.168.0.0/16 -j DROP
    iptables -t nat -A VM_ISOLATION_OUT -s "$subnet" -j MASQUERADE
    iptables -t nat -A POSTROUTING -j VM_ISOLATION_OUT
    
    # Forward rules - block host access
    iptables -A VM_ISOLATION_FORWARD -i "$vlan_interface" -d 10.0.0.0/8 -j DROP
    iptables -A VM_ISOLATION_FORWARD -i "$vlan_interface" -d 172.16.0.0/12 -j DROP
    iptables -A VM_ISOLATION_FORWARD -i "$vlan_interface" -d 192.168.0.0/16 -j DROP
    iptables -A VM_ISOLATION_FORWARD -i "$vlan_interface" -j ACCEPT
    iptables -A VM_ISOLATION_FORWARD -o "$vlan_interface" -m state --state RELATED,ESTABLISHED -j ACCEPT
    iptables -A FORWARD -j VM_ISOLATION_FORWARD
    
    print_success "Applied high security isolation rules"
}

# Medium security rules (balanced)
apply_medium_security_rules() {
    local bridge="$1"
    local vlan="$2"
    local topology="$3"
    
    local vlan_interface="${bridge}.${vlan}"
    local subnet="192.168.${vlan}.0/24"
    
    # Standard NAT with some restrictions
    iptables -t nat -A POSTROUTING -s "$subnet" ! -o "$bridge" -j MASQUERADE
    
    # Allow limited host access (SSH, HTTP, HTTPS only)
    iptables -A FORWARD -i "$vlan_interface" -p tcp --dport 22 -j ACCEPT
    iptables -A FORWARD -i "$vlan_interface" -p tcp --dport 80 -j ACCEPT
    iptables -A FORWARD -i "$vlan_interface" -p tcp --dport 443 -j ACCEPT
    iptables -A FORWARD -i "$vlan_interface" -o "$vlan_interface" -j ACCEPT
    iptables -A FORWARD -o "$vlan_interface" -m state --state RELATED,ESTABLISHED -j ACCEPT
    
    print_success "Applied medium security rules"
}

# Low security rules (basic NAT)
apply_low_security_rules() {
    local bridge="$1"
    local vlan="$2"
    local topology="$3"
    
    local vlan_interface="${bridge}.${vlan}"
    local subnet="192.168.${vlan}.0/24"
    
    # Basic NAT rules
    iptables -t nat -A POSTROUTING -s "$subnet" ! -o "$bridge" -j MASQUERADE
    iptables -A FORWARD -i "$vlan_interface" -j ACCEPT
    iptables -A FORWARD -o "$vlan_interface" -m state --state RELATED,ESTABLISHED -j ACCEPT
    
    print_success "Applied basic security rules"
}

# Penetration testing optimized rules
apply_pentest_security_rules() {
    local bridge="$1"
    local vlan="$2"
    local topology="$3"
    
    local vlan_interface="${bridge}.${vlan}"
    local subnet="10.${vlan}.1.0/24"
    
    # Optimized for pentesting tools
    iptables -t nat -A POSTROUTING -s "$subnet" ! -o "$bridge" -j MASQUERADE
    
    # Allow all outbound traffic
    iptables -A FORWARD -i "$vlan_interface" -j ACCEPT
    iptables -A FORWARD -o "$vlan_interface" -m state --state RELATED,ESTABLISHED -j ACCEPT
    
    # Enable packet forwarding optimizations
    echo 1 > /proc/sys/net/ipv4/ip_forward
    echo 0 > /proc/sys/net/ipv4/conf/all/rp_filter
    echo 0 > /proc/sys/net/ipv4/conf/"$vlan_interface"/rp_filter
    
    # Increase network buffer sizes for better performance
    echo 16777216 > /proc/sys/net/core/rmem_max
    echo 16777216 > /proc/sys/net/core/wmem_max
    
    print_success "Applied penetration testing optimized rules"
}

# Enable NAT forwarding
enable_nat_forwarding() {
    local bridge="$1"
    local interface="$2"
    
    iptables -t nat -A POSTROUTING -o "$interface" -j MASQUERADE
    iptables -A FORWARD -i "$bridge" -o "$interface" -j ACCEPT
    iptables -A FORWARD -i "$interface" -o "$bridge" -m state --state RELATED,ESTABLISHED -j ACCEPT
}

# Cleanup existing bridge configuration
cleanup_existing_bridge() {
    local bridge="$1"
    
    print_info "Cleaning up existing bridge configuration..."
    
    # Remove all VLAN interfaces associated with this bridge
    ip link show | grep "$bridge\." | awk '{print $2}' | cut -d':' -f1 | while read -r vlan_iface; do
        ip link delete "$vlan_iface" 2>/dev/null || true
    done
    
    # Remove bridge
    ip link set dev "$bridge" down 2>/dev/null || true
    ip link delete "$bridge" 2>/dev/null || true
    
    # Clean up iptables rules
    iptables -t nat -F 2>/dev/null || true
    iptables -t filter -F FORWARD 2>/dev/null || true
    
    print_success "Cleaned up existing bridge"
}

# --- END OF ENHANCED NETWORK SECTION ---

# Backup VM configuration
backup_vm_config() {
    local vm_name="$1"
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local backup_file="$BACKUP_DIR/${vm_name}_backup_${timestamp}.xml"

    mkdir -p "$BACKUP_DIR"

    if virsh dumpxml "$vm_name" > "$backup_file"; then
        print_success "VM configuration backed up to $backup_file"
        echo "$backup_file"
    else
        print_error "Failed to backup VM configuration"
        exit 1
    fi
}

# Generate enhanced network interface XML with multiple NICs support
generate_network_xml_enhanced() {
    local bridge="$1"
    local vlan="$2"
    local mac="$3"
    local pci_slot="$4"
    local nic_type="${5:-virtio}"  # Default to virtio, but allow other types
    local network_name="${6:-}"    # Optional network name

    # Different network interface types based on topology
    case "$NETWORK_TOPOLOGY" in
        "dual-nic")
            # Generate XML for dual NIC setup
            cat << EOF
    <interface type='bridge'>
      <mac address='$mac'/>
      <source bridge='$bridge'/>
      <vlan>
        <tag id='$vlan'/>
      </vlan>
      <model type='$nic_type'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='$pci_slot' function='0x0'/>
    </interface>
    <interface type='bridge'>
      <mac address='$(generate_mac)'/>
      <source bridge='${BRIDGE_NAME_SECONDARY:-br1}'/>
      <model type='$nic_type'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x$(printf "%02x" $((0x$pci_slot + 1)))' function='0x0'/>
    </interface>
EOF
            ;;
        "bridged")
            # Direct bridge without VLAN
            cat << EOF
    <interface type='bridge'>
      <mac address='$mac'/>
      <source bridge='$bridge'/>
      <model type='$nic_type'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='$pci_slot' function='0x0'/>
    </interface>
EOF
            ;;
        *)
            # Standard isolated network with VLAN
            cat << EOF
    <interface type='bridge'>
      <mac address='$mac'/>
      <source bridge='$bridge'/>
      <vlan>
        <tag id='$vlan'/>
      </vlan>
      <model type='$nic_type'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='$pci_slot' function='0x0'/>
    </interface>
EOF
            ;;
    esac
}


# Generate USB passthrough XML
generate_usb_xml() {
    local vendor="$1"
    local product="$2"
    local usb_port="$3"

    cat << EOF
    <hostdev mode='subsystem' type='usb' managed='yes'>
      <source>
        <vendor id='0x$vendor'/>
        <product id='0x$product'/>
      </source>
      <address type='usb' bus='0' port='$usb_port'/>
    </hostdev>
EOF
}

# Modify VM XML configuration
modify_vm_xml() {
    local vm_name="$1"
    local add_network="$2"
    local add_usb="$3"

    print_info "Modifying VM configuration for $vm_name..."

    if [[ "$DRY_RUN" == true ]]; then
        print_info "[DRY RUN] Would modify VM $vm_name"
        [[ "$add_network" == true ]] && print_info "[DRY RUN] Would add bridge network interface"
        [[ "$add_usb" == true ]] && print_info "[DRY RUN] Would add USB passthrough for $USB_VENDOR:$USB_PRODUCT"
        return
    fi

    # FIX: Check if VM is running and destroy it instead of exiting.
    if virsh list --state-running --name | grep -q "^$vm_name$"; then
        print_warning "VM $vm_name is running. It will be forcefully stopped to apply changes."
        virsh destroy "$vm_name" &> /dev/null || print_warning "Could not stop VM (may already be stopped)."
        print_info "Waiting for VM to shut down..."
        sleep 2
    fi

    # Backup configuration
    local backup_file=$(backup_vm_config "$vm_name")

    # Get current XML
    local temp_xml="/tmp/${vm_name}_modified.xml"
    virsh dumpxml "$vm_name" > "$temp_xml"

    # Assemble all XML additions
    local xml_additions=""
    if [[ "$add_network" == true ]]; then
        local mac=$(generate_mac)
        local pci_slot=$(find_next_pci_slot "$vm_name")
        xml_additions+=$(generate_network_xml_enhanced "$BRIDGE_NAME" "$VLAN_ID" "$mac" "$pci_slot")
        print_success "Generated network interface configuration"
    fi
    if [[ "$add_usb" == true ]]; then
        local usb_port=$(find_next_usb_port "$vm_name")
        xml_additions+=$(generate_usb_xml "$USB_VENDOR" "$USB_PRODUCT" "$usb_port")
        print_success "Generated USB passthrough configuration"
    fi

    # FIX: Use a robust method (awk) to insert XML before the </devices> tag.
    # This avoids the `sed` error caused by special characters in the XML.
    if [[ -n "$xml_additions" ]]; then
        local temp_modified_xml="${temp_xml}.new"
        awk -v new_content="$xml_additions" '
        /<\/devices>/ {
          print new_content
        }
        {
          print
        }
        ' "$temp_xml" > "$temp_modified_xml" && mv "$temp_modified_xml" "$temp_xml"
    fi

    # Validate XML
    if xmllint --noout "$temp_xml" 2>/dev/null; then
        print_success "XML validation passed"
    else
        print_error "XML validation failed. This is a critical error."
        print_info "The original configuration is safe in: $backup_file"
        print_info "The faulty generated XML is at: $temp_xml"
        exit 1
    fi

    # Apply configuration
    if virsh define "$temp_xml"; then
        print_success "VM configuration updated successfully"
        rm -f "$temp_xml"
    else
        print_error "Failed to apply VM configuration"
        print_info "Original configuration preserved in: $backup_file"
        rm -f "$temp_xml"
        exit 1
    fi
}

# Updated VM creation with proper OS variant support
create_new_vm() {
    local vm_name="$1"
    local iso_path="$2"
    local memory="$3"
    local cores="$4"
    local disk_size="$5"
    local os_variant="$6"  # New parameter for OS variant

    print_info "Creating new VM: $vm_name"

    if [[ "$DRY_RUN" == true ]]; then
        print_info "[DRY RUN] Would create VM with:"
        print_info "[DRY RUN]   Name: $vm_name"
        print_info "[DRY RUN]   ISO: $iso_path"
        print_info "[DRY RUN]   Memory: ${memory}MB"
        print_info "[DRY RUN]   Cores: $cores"
        print_info "[DRY RUN]   Disk: ${disk_size}GB"
        print_info "[DRY RUN]   OS Variant: $os_variant"
        return
    fi

    # Check if VM already exists and offer to delete it
    if virsh list --all --name | grep -q "^$vm_name$"; then
        print_warning "VM '$vm_name' already exists."
        read -p "Do you want to delete the existing VM and create a new one? [y/n]: " -r choice
        if [[ $choice =~ ^[Yy]$ ]]; then
            print_info "Deleting existing VM '$vm_name'..."
            virsh destroy "$vm_name" 2>/dev/null || true # Ignore error if not running
            virsh undefine "$vm_name" --remove-all-storage
            print_success "Existing VM '$vm_name' deleted."
        else
            print_error "VM creation cancelled."
            exit 1
        fi
    fi

    # Check if ISO exists
    if [[ ! -f "$iso_path" ]]; then
        print_error "ISO file not found: $iso_path"
        exit 1
    fi

    # Create VM disk directory
    local vm_dir="/var/lib/libvirt/images"
    local disk_path="$vm_dir/${vm_name}.qcow2"

    # Create VM with proper OS variant
    print_info "Creating VM with virt-install..."
    virt-install \
        --name "$vm_name" \
        --memory "$memory" \
        --vcpus "$cores" \
        --disk path="$disk_path",size="$disk_size",format=qcow2,bus=virtio \
        --cdrom "$iso_path" \
        --os-variant "$os_variant" \
        --network none \
        --graphics vnc,listen=0.0.0.0 \
        --noautoconsole \
        --boot cdrom,hd \
        --video virtio

    print_success "VM $vm_name created successfully"
    print_info "VM disk location: $disk_path"
    print_info "Connect via VNC to complete installation"
}

# Interactive VM selection
select_vm() {
    local vms
    if ! vms=$(detect_vms); then
        read -p "No existing VMs found. Create a new VM? (y/n): " -r
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            CREATE_NEW_VM=true
            return
        else
            exit 1
        fi
    fi

    echo "Available VMs:"
    local vm_array=()
    local i=1
    while IFS= read -r vm; do
        echo "$i) $vm"
        vm_array+=("$vm")
        ((i++))
    done <<< "$vms"

    echo "$i) Create new VM"

    while true; do
        read -p "Select VM (1-$i): " -r selection
        if [[ "$selection" =~ ^[0-9]+$ ]] && [[ "$selection" -ge 1 ]] && [[ "$selection" -le $i ]]; then
            if [[ "$selection" -eq $i ]]; then
                CREATE_NEW_VM=true
                break
            else
                VM_NAME="${vm_array[$((selection-1))]}"
                break
            fi
        else
            print_error "Invalid selection. Please enter a number between 1 and $i."
        fi
    done
}

# Interactive USB adapter selection
select_usb_adapter() {
    local adapters_output
    if ! adapters_output=$(detect_usb_adapters); then
        # The function already prints a warning to stderr
        return 1
    fi

    echo "Detected USB WiFi adapters:"
    local adapter_array=()
    local i=1
    while IFS='|' read -r vendor_product info; do
        IFS=':' read -r name monitor inject rating <<< "$info"
        
        local status_color=""
        case "$rating" in
            "recommended") status_color="$GREEN" ;;
            "good") status_color="$YELLOW" ;;
            *) status_color="$NC" ;;
        esac
        
        echo -e "$i) ${status_color}$name ($vendor_product)${NC} - Monitor: $monitor, Injection: $inject [$rating]"
        adapter_array+=("$vendor_product")
        ((i++))
    done <<< "$adapters_output"
    
    echo "$i) Skip USB passthrough"
    
    while true; do
        read -p "Select adapter (1-$i): " -r selection
        if [[ "$selection" =~ ^[0-9]+$ ]] && [[ "$selection" -ge 1 ]] && [[ "$selection" -le $i ]]; then
            if [[ "$selection" -eq $i ]]; then
                return 1
            else
                local selected_adapter="${adapter_array[$((selection-1))]}"
                USB_VENDOR="${selected_adapter%:*}"
                USB_PRODUCT="${selected_adapter#*:}"
                return 0
            fi
        else
            print_error "Invalid selection."
        fi
    done
}

# Updated interactive new VM setup with download option
setup_new_vm() {
    print_info "Setting up new VM..."

    # Get VM name
    while [[ -z "$VM_NAME" ]]; do
        read -p "Enter VM name: " -r VM_NAME
    done

    # Ask for ISO source
    echo "Choose ISO source:"
    echo "1) Use existing ISO file"
    echo "2) Download ISO automatically"

    while true; do
        read -p "Select option (1-2): " -r iso_choice
        case $iso_choice in
            1)
                # Use existing ISO
                while [[ -z "$ISO_PATH" || ! -f "$ISO_PATH" ]]; do
                    read -p "Enter path to ISO file: " -r user_input
                    # Sanitize the input
                    local temp_path
                    temp_path=$(echo "$user_input" | xargs)
                    temp_path="${temp_path//\'/}"
                    temp_path="${temp_path//\"/}"
                    
                    # FIX: Replaced unsafe `eval` with a safe way to handle tilde expansion.
                    if [[ "${temp_path:0:1}" == "~" ]]; then
                        ISO_PATH="$HOME${temp_path:1}"
                    else
                        ISO_PATH="$temp_path"
                    fi

                    if [[ ! -f "$ISO_PATH" ]]; then
                        print_error "ISO file not found: '$ISO_PATH'"
                        ISO_PATH=""
                    fi
                done

                # Try to detect OS from filename
                VM_OS_VARIANT=$(select_os_variant)
                break
                ;;
            2)
                # Download ISO
                echo "Available distributions for download:"
                local distros=()
                local i=1
                for distro in "${!ISO_URLS[@]}"; do
                    echo "$i) $distro"
                    distros+=("$distro")
                    ((i++))
                done

                while true; do
                    read -p "Select distribution (1-$((i-1))): " -r distro_choice
                    if [[ "$distro_choice" =~ ^[0-9]+$ ]] && [[ "$distro_choice" -ge 1 ]] && [[ "$distro_choice" -lt $i ]]; then
                        local selected_distro="${distros[$((distro_choice-1))]}"

                        # Download the ISO
                        if ISO_PATH=$(download_iso "$selected_distro"); then
                            VM_OS_VARIANT="${OS_VARIANTS[$selected_distro]:-linux2022}"
                            break 2
                        else
                            print_error "Failed to download $selected_distro"
                            continue
                        fi
                    else
                        print_error "Invalid selection"
                    fi
                done
                ;;
            *)
                print_error "Invalid option. Please select 1 or 2."
                ;;
        esac
    done

    # Get system resources and recommendations
    print_system_resources
    local resources=$(get_system_resource_recommendations)
    IFS=':' read -r rec_memory min_memory max_memory rec_cores min_cores max_cores <<< "$resources"

    # Get memory
    while [[ -z "$VM_MEMORY" ]]; do
        read -p "Enter memory in MB (min: $min_memory, recommended: $rec_memory, max: $max_memory): " -r VM_MEMORY
        if [[ ! "$VM_MEMORY" =~ ^[0-9]+$ ]] || [[ "$VM_MEMORY" -lt $min_memory ]] || [[ "$VM_MEMORY" -gt $max_memory ]]; then
            print_error "Memory must be between $min_memory and $max_memory MB"
            VM_MEMORY=""
        fi
    done

    # Get cores
    while [[ -z "$VM_CORES" ]]; do
        read -p "Enter CPU cores (min: $min_cores, recommended: $rec_cores, max: $max_cores): " -r VM_CORES
        if [[ ! "$VM_CORES" =~ ^[0-9]+$ ]] || [[ "$VM_CORES" -lt $min_cores ]] || [[ "$VM_CORES" -gt $max_cores ]]; then
            print_error "Cores must be between $min_cores and $max_cores"
            VM_CORES=""
        fi
    done

    # Get disk size
    while [[ -z "$VM_DISK_SIZE" ]]; do
        read -p "Enter disk size in GB (minimum 20, recommended 40): " -r VM_DISK_SIZE
        if [[ ! "$VM_DISK_SIZE" =~ ^[0-9]+$ ]] || [[ "$VM_DISK_SIZE" -lt 20 ]]; then
            print_error "Disk size must be at least 20 GB"
            VM_DISK_SIZE=""
        fi
    done
}

# Make bridge persistent
make_persistent() {
    local interface="$1"
    local bridge="$2"
    local vlan="$3"

    print_info "Making bridge configuration persistent..."

    if [[ "$DRY_RUN" == true ]]; then
        print_info "[DRY RUN] Would create persistent network configuration"
        return
    fi

    # Create netplan configuration (Ubuntu/Debian)
    if command -v netplan &> /dev/null; then
        local netplan_file="/etc/netplan/99-vm-isolation.yaml"
        cat > "$netplan_file" << EOF
network:
  version: 2
  ethernets:
    $interface:
      dhcp4: false
  bridges:
    $bridge:
      interfaces: [$interface]
      dhcp4: true
      parameters:
        stp: false
  vlans:
    ${bridge}.${vlan}:
      id: $vlan
      link: $bridge
      addresses: [192.168.${vlan}.1/24]
EOF
        print_success "Created netplan configuration: $netplan_file"

    # Create systemd-networkd configuration
    else
        local networkd_dir="/etc/systemd/network"
        mkdir -p "$networkd_dir"

        # Bridge configuration
        cat > "$networkd_dir/99-$bridge.netdev" << EOF
[NetDev]
Name=$bridge
Kind=bridge
EOF

        cat > "$networkd_dir/99-$bridge.network" << EOF
[Match]
Name=$bridge

[Network]
DHCP=yes
IPForward=yes
EOF

        # Interface configuration
        cat > "$networkd_dir/99-$interface.network" << EOF
[Match]
Name=$interface

[Network]
Bridge=$bridge
EOF

        # VLAN configuration
        cat > "$networkd_dir/99-${bridge}.${vlan}.netdev" << EOF
[NetDev]
Name=${bridge}.${vlan}
Kind=vlan

[VLAN]
Id=$vlan
EOF

        cat > "$networkd_dir/99-${bridge}.${vlan}.network" << EOF
[Match]
Name=${bridge}.${vlan}

[Network]
Address=192.168.${vlan}.1/24
EOF

        systemctl enable systemd-networkd
        print_success "Created systemd-networkd configuration"
    fi
}

# Show post-setup instructions
show_post_setup_instructions() {
    local vm_name="$1"
    local has_network="$2"
    local has_usb="$3"

    print_success "VM Lab Isolation Setup Complete!"
    echo
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo -e "${GREEN}✅ SETUP SUMMARY${NC}"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo -e "VM Name: ${BLUE}$vm_name${NC}"

    if [[ "$has_network" == true ]]; then
        echo -e "Network: ${GREEN}Bridge networking with VLAN isolation${NC}"
        echo "  - Bridge: $BRIDGE_NAME"
        echo "  - VLAN: $VLAN_ID"
        echo "  - Gateway: 192.168.${VLAN_ID}.1"
    fi

    if [[ "$has_usb" == true ]]; then
        echo -e "USB WiFi: ${GREEN}$USB_VENDOR:$USB_PRODUCT passthrough enabled${NC}"
    fi

    echo
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo -e "${YELLOW}📋 NEXT STEPS${NC}"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

    echo "1. Start your VM:"
    echo "   virsh start $vm_name"
    echo

    if [[ "$has_network" == true ]]; then
        echo "2. Configure networking inside VM:"
        echo "   # Option 1: NetworkManager (recommended)"
        echo "   nmcli device connect eth0"
        echo
        echo "   # Option 2: Manual configuration"
        echo "   sudo ip addr add 192.168.${VLAN_ID}.10/24 dev eth0"
        echo "   sudo ip route add default via 192.168.${VLAN_ID}.1"
        echo "   echo \"nameserver 8.8.8.8\" | sudo tee /etc/resolv.conf"
        echo
        echo "3. Test connectivity:"
        echo "   ping google.com"
        echo
    fi

    if [[ "$has_usb" == true ]]; then
        echo "4. USB WiFi adapter available as wlan0 for penetration testing"
        echo "   # Check if detected"
        echo "   iwconfig"
        echo "   # Enable monitor mode"
        echo "   sudo airmon-ng start wlan0"
        echo
    fi

    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo -e "${BLUE}🌐 NETWORK TOPOLOGY${NC}"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

    if [[ "$has_network" == true ]]; then
        echo "Host System ── $HOST_INTERFACE ── Bridge $BRIDGE_NAME ── Internet"
        echo "                                    │"
        echo "                                VLAN $VLAN_ID ── VM eth0 (isolated)"
    fi

    if [[ "$has_usb" == true ]]; then
        echo "USB WiFi Adapter ──────────────────── VM wlan0 (direct passthrough)"
    fi

    echo
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo -e "${GREEN}🔧 MANAGEMENT COMMANDS${NC}"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "Start VM:     virsh start $vm_name"
    echo "Stop VM:      virsh shutdown $vm_name"
    echo "VM Console:   virsh console $vm_name"
    echo "VM VNC:       virt-viewer $vm_name"
    echo "VM Status:    virsh list --all"
    echo
    echo "Bridge Info:  ip addr show $BRIDGE_NAME"
    echo "VLAN Info:    ip addr show $BRIDGE_NAME.$VLAN_ID"
    echo "USB Devices:  lsusb"
    echo
    echo "Backup saved: $BACKUP_DIR/"
    echo "Logs saved:   $LOG_FILE"
    echo
    echo -e "${GREEN}Happy Pentesting! 🎯${NC}"
    echo "Created by: 0xbv1 | 0xb0rn3 (github.com/0xb0rn3/Qemu-pentest)"
}

# List supported adapters
list_adapters() {
    echo "Supported USB WiFi Adapters:"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    printf "%-15s %-25s %-8s %-10s %-12s\n" "Vendor:Product" "Name" "Monitor" "Injection" "Rating"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

    for adapter in "${!ADAPTERS[@]}"; do
        local info="${ADAPTERS[$adapter]}"
        local name=$(echo "$info" | cut -d':' -f1)
        local monitor=$(echo "$info" | cut -d':' -f2)
        local inject=$(echo "$info" | cut -d':' -f3)
        local rating=$(echo "$info" | cut -d':' -f4)

        local rating_color=""
        case "$rating" in
            "recommended") rating_color="$GREEN" ;;
            "good") rating_color="$YELLOW" ;;
            *) rating_color="$NC" ;;
        esac

        printf "%-15s %-25s %-8s %-10s ${rating_color}%-12s${NC}\n" "$adapter" "$name" "$monitor" "$inject" "$rating"
    done
    echo
}

# List VMs
list_vms() {
    echo "Available VMs:"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    virsh list --all --name | while read -r vm; do
        [[ -n "$vm" ]] && echo "  $vm"
    done
    echo
}

# Restore VM from backup
restore_vm() {
    local backup_file="$1"

    if [[ ! -f "$backup_file" ]]; then
        print_error "Backup file not found: $backup_file"
        exit 1
    fi

    # Extract VM name from backup filename
    local vm_name=$(basename "$backup_file" | sed 's/_backup_.*\.xml$//')

    print_info "Restoring VM $vm_name from backup..."

    if [[ "$DRY_RUN" == true ]]; then
        print_info "[DRY RUN] Would restore VM $vm_name from $backup_file"
        return
    fi

    # FIX: Check if VM is running and destroy it before restoring.
    if virsh list --state-running --name | grep -q "^$vm_name$"; then
        print_warning "VM $vm_name is running. It will be forcefully stopped to restore the configuration."
        virsh destroy "$vm_name" &> /dev/null || print_warning "Could not stop VM (may already be stopped)."
        sleep 2
    fi

    # Validate backup XML
    if ! xmllint --noout "$backup_file" 2>/dev/null; then
        print_error "Invalid XML in backup file"
        exit 1
    fi

    # Apply backup configuration
    if virsh define "$backup_file"; then
        print_success "VM $vm_name restored from backup"
    else
        print_error "Failed to restore VM from backup"
        exit 1
    fi
}

# Main interactive setup
interactive_setup() {
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo -e "${GREEN}VM Lab Isolation Setup v$SCRIPT_VERSION${NC}"
    echo "Author: 0xbv1 | 0xb0rn3 (github.com/0xb0rn3/Qemu-pentest)"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo

    # VM Selection
    select_vm

    if [[ "$CREATE_NEW_VM" == true ]]; then
        setup_new_vm
    fi

    # Network setup
    print_info "Configuring network topology and security..."
    NETWORK_TOPOLOGY=$(select_network_topology)
    SECURITY_LEVEL=$(select_security_level)
    HOST_INTERFACE=$(select_network_interface_enhanced)

    # USB adapter setup
    print_info "Configuring USB WiFi passthrough..."
    local has_usb=false
    if select_usb_adapter; then
        has_usb=true
    fi

    # Confirmation
    echo
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo -e "${YELLOW}CONFIGURATION SUMMARY${NC}"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

    if [[ "$CREATE_NEW_VM" == true ]]; then
        echo "Action: Create new VM"
        echo "VM Name: $VM_NAME"
        echo "ISO: $ISO_PATH"
        echo "Memory: ${VM_MEMORY}MB"
        echo "Cores: $VM_CORES"
        echo "Disk: ${VM_DISK_SIZE}GB"
    else
        echo "Action: Configure existing VM"
        echo "VM Name: $VM_NAME"
    fi

    echo "Host Interface: $HOST_INTERFACE"
    echo "Bridge: $BRIDGE_NAME"
    echo "VLAN: $VLAN_ID"
    echo "Network Topology: $NETWORK_TOPOLOGY"
    echo "Security Level: $SECURITY_LEVEL"


    if [[ "$has_usb" == true ]]; then
        echo "USB WiFi: $USB_VENDOR:$USB_PRODUCT"
    else
        echo "USB WiFi: Skipped"
    fi

    echo
    read -p "Proceed with configuration? (y/n): " -r
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        print_info "Configuration cancelled"
        exit 0
    fi

    # Execute configuration
    print_info "Starting configuration..."

    # Create bridge network
    create_bridge_enhanced "$HOST_INTERFACE" "$BRIDGE_NAME" "$VLAN_ID" "$NETWORK_TOPOLOGY" "$SECURITY_LEVEL"

    # Create VM if needed
    if [[ "$CREATE_NEW_VM" == true ]]; then
        create_new_vm "$VM_NAME" "$ISO_PATH" "$VM_MEMORY" "$VM_CORES" "$VM_DISK_SIZE" "$VM_OS_VARIANT"
    fi

    # Modify VM configuration
    modify_vm_xml "$VM_NAME" true "$has_usb"

    # Make persistent if requested
    if [[ "$PERSISTENT" == true ]]; then
        make_persistent "$HOST_INTERFACE" "$BRIDGE_NAME" "$VLAN_ID"
    fi

    # Show final instructions
    show_post_setup_instructions "$VM_NAME" true "$has_usb"
}

# Parse command line arguments
parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --vm)
                VM_NAME="$2"
                shift 2
                ;;
            --create-vm)
                CREATE_NEW_VM=true
                shift
                ;;
            --iso)
                ISO_PATH="$2"
                shift 2
                ;;
            --download-iso)
                # This will be handled in the main logic
                shift
                ;;
            --adapter)
                if [[ "$2" =~ ^[0-9a-f]{4}:[0-9a-f]{4}$ ]]; then
                    USB_VENDOR="${2%:*}"
                    USB_PRODUCT="${2#*:}"
                else
                    print_error "Invalid adapter format. Use: vendor:product (e.g., 0e8d:7612)"
                    exit 1
                fi
                shift 2
                ;;
            --vlan)
                VLAN_ID="$2"
                shift 2
                ;;
            --interface)
                HOST_INTERFACE="$2"
                shift 2
                ;;
            --bridge)
                BRIDGE_NAME="$2"
                shift 2
                ;;
            --memory)
                VM_MEMORY="$2"
                shift 2
                ;;
            --cores)
                VM_CORES="$2"
                shift 2
                ;;
            --disk)
                VM_DISK_SIZE="$2"
                shift 2
                ;;
            --persistent)
                PERSISTENT=true
                shift
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --restore)
                restore_vm "$2"
                exit 0
                ;;
            --list-adapters)
                list_adapters
                exit 0
                ;;
            --list-vms)
                list_vms
                exit 0
                ;;
            --verbose)
                VERBOSE=true
                shift
                ;;
            --help)
                show_help
                exit 0
                ;;
            *)
                print_error "Unknown option: $1"
                show_help
                exit 1
                ;;
        esac
    done
}

# Main function
main() {
    # Initialize logging
    echo "VM Lab Isolation Setup started at $(date)" > "$LOG_FILE"

    # Parse arguments
    parse_arguments "$@"

    # Perform checks
    check_root
    check_dependencies
    check_libvirt

    # If parameters provided via CLI, use non-interactive mode
    if [[ -n "$VM_NAME" || "$CREATE_NEW_VM" == true ]]; then
        print_info "Running in non-interactive mode..."

        # Validate required parameters for new VM
        if [[ "$CREATE_NEW_VM" == true ]]; then
            if [[ -z "$ISO_PATH" ]]; then
                setup_new_vm # Enter interactive mode to get ISO
            fi
            [[ -z "$VM_NAME" ]] && { print_error "VM name required for new VM creation"; exit 1; }
            [[ -z "$VM_MEMORY" ]] && VM_MEMORY="2048"
            [[ -z "$VM_CORES" ]] && VM_CORES="2"
            [[ -z "$VM_DISK_SIZE" ]] && VM_DISK_SIZE="40"
        fi

        # Auto-detect missing parameters and set defaults for new options
        [[ -z "$HOST_INTERFACE" ]] && HOST_INTERFACE=$(detect_network_interfaces_enhanced | cut -d'|' -f1 | head -1)
        [[ -z "$NETWORK_TOPOLOGY" ]] && NETWORK_TOPOLOGY="isolated"
        [[ -z "$SECURITY_LEVEL" ]] && SECURITY_LEVEL="medium"


        # Check if we have USB adapter
        local has_usb=false
        if [[ -n "$USB_VENDOR" && -n "$USB_PRODUCT" ]]; then
            has_usb=true
        fi

        # Execute configuration
        create_bridge_enhanced "$HOST_INTERFACE" "$BRIDGE_NAME" "$VLAN_ID" "$NETWORK_TOPOLOGY" "$SECURITY_LEVEL"

        if [[ "$CREATE_NEW_VM" == true ]]; then
            create_new_vm "$VM_NAME" "$ISO_PATH" "$VM_MEMORY" "$VM_CORES" "$VM_DISK_SIZE" "$VM_OS_VARIANT"
        fi

        modify_vm_xml "$VM_NAME" true "$has_usb"

        if [[ "$PERSISTENT" == true ]]; then
            make_persistent "$HOST_INTERFACE" "$BRIDGE_NAME" "$VLAN_ID"
        fi

        show_post_setup_instructions "$VM_NAME" true "$has_usb"
    else
        # Run interactive setup
        interactive_setup
    fi

    # Add cleanup at the end of main() function
    cleanup_fastdl

    print_success "Setup completed successfully!"
    log "Setup completed successfully"
}

# Handle script interruption
trap 'cleanup_fastdl; print_error "Script interrupted"; exit 1' INT TERM

# Run main function
main "$@"
